From 17388cc3bab07a907df4cffcf901e9c1a1c8b6a3 Mon Sep 17 00:00:00 2001
From: Axel Naumann <Axel.Naumann@cern.ch>
Date: Fri, 9 Sep 2016 16:58:55 +0200
Subject: [PATCH 36/83] Keep the collection of EmittedDeferredDecls for
 subsequent transactions.

---
 lib/CodeGen/CodeGenModule.cpp | 19 ++++++++++++-------
 lib/CodeGen/CodeGenModule.h   | 24 +++++++++++++++++++++++-
 lib/CodeGen/ModuleBuilder.cpp | 12 +++++++++---
 3 files changed, 44 insertions(+), 11 deletions(-)

diff --git a/lib/CodeGen/CodeGenModule.cpp b/lib/CodeGen/CodeGenModule.cpp
index 49a1396b58..c9d502706b 100644
--- a/lib/CodeGen/CodeGenModule.cpp
+++ b/lib/CodeGen/CodeGenModule.cpp
@@ -410,6 +410,7 @@ void CodeGenModule::checkAliases() {
 
 void CodeGenModule::clear() {
   DeferredDeclsToEmit.clear();
+  EmittedDeferredDecls.clear();
   if (OpenMPRuntime)
     OpenMPRuntime->clear();
 }
@@ -475,6 +476,9 @@ static void setVisibilityFromDLLStorageClass(const clang::LangOptions &LO,
 
 void CodeGenModule::Release() {
   EmitDeferred();
+  DeferredDecls.insert(EmittedDeferredDecls.begin(),
+                       EmittedDeferredDecls.end());
+  EmittedDeferredDecls.clear();
   EmitVTablesOpportunistically();
   applyGlobalValReplacements();
   applyReplacements();
@@ -2411,7 +2415,7 @@ void CodeGenModule::EmitDeferred() {
   // needed for further handling.
   if (getLangOpts().CUDA && getLangOpts().CUDAIsDevice)
     for (const auto *V : getContext().CUDADeviceVarODRUsedByHost)
-      DeferredDeclsToEmit.push_back(V);
+      addDeferredDeclToEmit(V, "");
 
   // Stop if we're out of both deferred vtables and deferred declarations.
   if (DeferredDeclsToEmit.empty())
@@ -2980,6 +2984,7 @@ void CodeGenModule::EmitGlobal(GlobalDecl GD) {
   if (MustBeEmitted(Global) && MayBeEmittedEagerly(Global)) {
     // Emit the definition if it can't be deferred.
     EmitGlobalDefinition(GD);
+    addEmittedDeferredDecl(GD, StringRef());
     return;
   }
 
@@ -2994,11 +2999,11 @@ void CodeGenModule::EmitGlobal(GlobalDecl GD) {
   StringRef MangledName = getMangledName(GD);
   if (GetGlobalValue(MangledName) != nullptr) {
     // The value has already been used and should therefore be emitted.
-    addDeferredDeclToEmit(GD);
+    addDeferredDeclToEmit(GD, MangledName);
   } else if (MustBeEmitted(Global)) {
     // The value must be emitted, but cannot be emitted eagerly.
     assert(!MayBeEmittedEagerly(Global));
-    addDeferredDeclToEmit(GD);
+    addDeferredDeclToEmit(GD, MangledName);
   } else {
     // Otherwise, remember that we saw a deferred decl with this name.  The
     // first use of the mangled name will cause it to move into
@@ -3625,7 +3630,7 @@ llvm::Constant *CodeGenModule::GetOrCreateLLVMFunction(
     if (D && isa<CXXDestructorDecl>(D) &&
         getCXXABI().useThunkForDtorVariant(cast<CXXDestructorDecl>(D),
                                            GD.getDtorType()))
-      addDeferredDeclToEmit(GD);
+      addDeferredDeclToEmit(GD, MangledName);
 
     // This is the first use or definition of a mangled name.  If there is a
     // deferred decl with this name, remember that we need to emit it at the end
@@ -3635,7 +3640,7 @@ llvm::Constant *CodeGenModule::GetOrCreateLLVMFunction(
       // Move the potentially referenced deferred decl to the
       // DeferredDeclsToEmit list, and remove it from DeferredDecls (since we
       // don't need it anymore).
-      addDeferredDeclToEmit(DDI->second);
+      addDeferredDeclToEmit(DDI->second, MangledName);
       DeferredDecls.erase(DDI);
 
       // Otherwise, there are cases we have to worry about where we're
@@ -3655,7 +3660,7 @@ llvm::Constant *CodeGenModule::GetOrCreateLLVMFunction(
            FD = FD->getPreviousDecl()) {
         if (isa<CXXRecordDecl>(FD->getLexicalDeclContext())) {
           if (FD->doesThisDeclarationHaveABody()) {
-            addDeferredDeclToEmit(GD.getWithDecl(FD));
+            addDeferredDeclToEmit(GD.getWithDecl(FD), MangledName);
             break;
           }
         }
@@ -3908,7 +3913,7 @@ CodeGenModule::GetOrCreateLLVMGlobal(StringRef MangledName, llvm::Type *Ty,
   if (DDI != DeferredDecls.end()) {
     // Move the potentially referenced deferred decl to the DeferredDeclsToEmit
     // list, and remove it from DeferredDecls (since we don't need it anymore).
-    addDeferredDeclToEmit(DDI->second);
+    addDeferredDeclToEmit(DDI->second, MangledName);
     DeferredDecls.erase(DDI);
   }
 
diff --git a/lib/CodeGen/CodeGenModule.h b/lib/CodeGen/CodeGenModule.h
index d2f0f1eff7..6395c81a27 100644
--- a/lib/CodeGen/CodeGenModule.h
+++ b/lib/CodeGen/CodeGenModule.h
@@ -37,6 +37,8 @@
 #include "llvm/IR/ValueHandle.h"
 #include "llvm/Transforms/Utils/SanitizerStats.h"
 
+#include <unordered_map>
+
 namespace llvm {
 class Module;
 class Constant;
@@ -348,11 +350,31 @@ private:
   /// yet.
   std::map<StringRef, GlobalDecl> DeferredDecls;
 
+  /// Decls that were DeferredDecls and have now been emitted.
+  std::map<StringRef, GlobalDecl> EmittedDeferredDecls;
+  void addEmittedDeferredDecl(GlobalDecl GD, StringRef MangledName) {
+    bool IsAFunction = isa<FunctionDecl>(GD.getDecl());
+    const VarDecl* VD = IsAFunction ? nullptr : dyn_cast<VarDecl>(GD.getDecl());
+    assert((IsAFunction || VD) && "Unexpected Decl type!");
+    bool ExcludeCtor = false; // FIXME: this is too simple!
+    llvm::GlobalValue::LinkageTypes L
+      = IsAFunction ? getFunctionLinkage(GD) :
+      getLLVMLinkageVarDefinition(VD, isTypeConstant(VD->getType(),
+                                                     ExcludeCtor));
+    if (llvm::GlobalValue::isWeakForLinker(L)
+        || llvm::GlobalValue::isInternalLinkage(L)) {
+      if (MangledName.empty())
+        MangledName = getMangledName(GD);
+      EmittedDeferredDecls[MangledName] = GD;
+    }
+  }
+
   /// This is a list of deferred decls which we have seen that *are* actually
   /// referenced. These get code generated when the module is done.
   std::vector<GlobalDecl> DeferredDeclsToEmit;
-  void addDeferredDeclToEmit(GlobalDecl GD) {
+  void addDeferredDeclToEmit(GlobalDecl GD, StringRef MangledName) {
     DeferredDeclsToEmit.emplace_back(GD);
+    addEmittedDeferredDecl(GD, MangledName);
   }
 
   /// List of alias we have emitted. Used to make sure that what they point to
diff --git a/lib/CodeGen/ModuleBuilder.cpp b/lib/CodeGen/ModuleBuilder.cpp
index 5ad3d383e5..ef5dc54035 100644
--- a/lib/CodeGen/ModuleBuilder.cpp
+++ b/lib/CodeGen/ModuleBuilder.cpp
@@ -148,6 +148,9 @@ namespace clang {
              && "Newly created module should not have deferred decls");
       Builder->DeferredDecls.swap(OldBuilder->DeferredDecls);
 
+      assert(OldBuilder->EmittedDeferredDecls.empty()
+             && "Still have (unmerged) EmittedDeferredDecls deferred decls");
+
       assert(Builder->DeferredVTables.empty()
              && "Newly created module should not have deferred vtables");
       Builder->DeferredVTables.swap(OldBuilder->DeferredVTables);
@@ -162,7 +165,6 @@ namespace clang {
              && "Newly created module should not have weakRefRefs");
       Builder->WeakRefReferences.swap(OldBuilder->WeakRefReferences);
 
-
       return M.get();
     }
 
@@ -189,8 +191,7 @@ namespace clang {
       out << " DeferredDeclsToEmit (std::vector<DeferredGlobal>)\n";
       for(auto I = Builder->DeferredDeclsToEmit.begin(),
             E = Builder->DeferredDeclsToEmit.end(); I != E; ++I) {
-        I->GD.getDecl()->print(out);
-        I->GV->print(out);
+        I->getDecl()->print(out);
         out << "\n";
       }
 
@@ -298,6 +299,11 @@ namespace clang {
       }
     }
 
+    void forgetDecl(const GlobalDecl& GD) {
+      StringRef MangledName = Builder->getMangledName(GD);
+      Builder->DeferredDecls.erase(MangledName);
+    }
+
     void Initialize(ASTContext &Context) override {
       Ctx = &Context;
 
-- 
2.34.1

