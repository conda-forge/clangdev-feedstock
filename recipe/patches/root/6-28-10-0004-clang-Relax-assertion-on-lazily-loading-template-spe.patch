From 713149a77ae229707761a57ed9070e10b0b967fb Mon Sep 17 00:00:00 2001
From: Jonas Hahnfeld <jonas.hahnfeld@cern.ch>
Date: Mon, 3 Jul 2023 08:05:14 +0200
Subject: [PATCH 4/8] [clang] Relax assertion on lazily loading template specs

Due to hash collisions, it can happen that we load another template
specialization with the same hash. This is fine, as long as the next
call to findSpecializationImpl does not find a matching Decl for the
template arguments.

(cherry picked from commit 13abc9f0145614965be62fd985855a84541a9fe3)
---
 .../tools/clang/include/clang/AST/DeclTemplate.h  |  3 +--
 .../llvm/src/tools/clang/lib/AST/DeclTemplate.cpp | 15 ++++++++-------
 2 files changed, 9 insertions(+), 9 deletions(-)

diff --git a/interpreter/llvm/src/tools/clang/include/clang/AST/DeclTemplate.h b/interpreter/llvm/src/tools/clang/include/clang/AST/DeclTemplate.h
index 8e3ee2734f..e7a011bdae 100644
--- a/interpreter/llvm/src/tools/clang/include/clang/AST/DeclTemplate.h
+++ b/interpreter/llvm/src/tools/clang/include/clang/AST/DeclTemplate.h
@@ -828,8 +828,7 @@ protected:
 
   void loadLazySpecializationsImpl(bool OnlyPartial = false) const;
 
-  ///\returns true if any lazy specialization was loaded.
-  bool loadLazySpecializationsImpl(llvm::ArrayRef<TemplateArgument> Args,
+  void loadLazySpecializationsImpl(llvm::ArrayRef<TemplateArgument> Args,
                                    TemplateParameterList *TPL = nullptr) const;
 
   Decl *loadLazySpecializationImpl(LazySpecializationInfo &LazySpecInfo) const;
diff --git a/interpreter/llvm/src/tools/clang/lib/AST/DeclTemplate.cpp b/interpreter/llvm/src/tools/clang/lib/AST/DeclTemplate.cpp
index 4b1ea6dac0..8fb204ef7d 100644
--- a/interpreter/llvm/src/tools/clang/lib/AST/DeclTemplate.cpp
+++ b/interpreter/llvm/src/tools/clang/lib/AST/DeclTemplate.cpp
@@ -309,19 +309,17 @@ Decl *RedeclarableTemplateDecl::loadLazySpecializationImpl(
   return getASTContext().getExternalSource()->GetExternalDecl(ID);
 }
 
-bool
+void
 RedeclarableTemplateDecl::loadLazySpecializationsImpl(ArrayRef<TemplateArgument>
                                                       Args,
                                                       TemplateParameterList *TPL) const {
-  bool LoadedSpecialization = false;
   CommonBase *CommonBasePtr = getMostRecentDecl()->getCommonPtr();
   if (auto *Specs = CommonBasePtr->LazySpecializations) {
     unsigned Hash = TemplateArgumentList::ComputeODRHash(Args);
     for (uint32_t I = 0, N = Specs[0].DeclID; I != N; ++I)
       if (Specs[I+1].ODRHash && Specs[I+1].ODRHash == Hash)
-        LoadedSpecialization |= (bool)loadLazySpecializationImpl(Specs[I+1]);
+        (void)loadLazySpecializationImpl(Specs[I+1]);
   }
-  return LoadedSpecialization;
 }
 
 template<class EntryType, typename... ProfileArguments>
@@ -331,7 +329,7 @@ RedeclarableTemplateDecl::findSpecializationImpl(
     ProfileArguments&&... ProfileArgs) {
   using SETraits = SpecEntryTraits<EntryType>;
 
-  (void)loadLazySpecializationsImpl(std::forward<ProfileArguments>(ProfileArgs)...);
+  loadLazySpecializationsImpl(std::forward<ProfileArguments>(ProfileArgs)...);
 
   llvm::FoldingSetNodeID ID;
   EntryType::Profile(ID, std::forward<ProfileArguments>(ProfileArgs)...,
@@ -349,8 +347,11 @@ void RedeclarableTemplateDecl::addSpecializationImpl(
   if (InsertPos) {
 #ifndef NDEBUG
     auto Args = SETraits::getTemplateArgs(Entry);
-    assert(!loadLazySpecializationsImpl(Args) &&
-           "Specialization is already registered as lazy");
+    // Due to hash collisions, it can happen that we load another template
+    // specialization with the same hash. This is fine, as long as the next
+    // call to findSpecializationImpl does not find a matching Decl for the
+    // template arguments.
+    loadLazySpecializationsImpl(Args);
     void *CorrectInsertPos;
     assert(!findSpecializationImpl(Specializations, CorrectInsertPos, Args) &&
            InsertPos == CorrectInsertPos &&
-- 
2.42.0

