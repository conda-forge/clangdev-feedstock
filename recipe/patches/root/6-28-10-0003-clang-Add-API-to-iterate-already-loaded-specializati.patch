From 1e12b44dbd3afe1a714e894ce2cd4d0f8caaaff2 Mon Sep 17 00:00:00 2001
From: Jonas Hahnfeld <jonas.hahnfeld@cern.ch>
Date: Fri, 30 Jun 2023 16:39:18 +0200
Subject: [PATCH 3/8] [clang] Add API to iterate already loaded specializations

This avoids deserialization if necessary, for example in DeclUnloader.

See also https://reviews.llvm.org/D154328

(cherry picked from commit 73a9a58c9260ed8337ff7046d95aadf093b89b7a)
---
 .../clang/include/clang/AST/DeclTemplate.h    | 42 +++++++++++++++++++
 1 file changed, 42 insertions(+)

diff --git a/interpreter/llvm/src/tools/clang/include/clang/AST/DeclTemplate.h b/interpreter/llvm/src/tools/clang/include/clang/AST/DeclTemplate.h
index e6b261edf1..8e3ee2734f 100644
--- a/interpreter/llvm/src/tools/clang/include/clang/AST/DeclTemplate.h
+++ b/interpreter/llvm/src/tools/clang/include/clang/AST/DeclTemplate.h
@@ -1119,6 +1119,20 @@ public:
     return makeSpecIterator(getSpecializations(), true);
   }
 
+  /// All specializations that that have already been loaded, ie avoiding
+  /// deserialization of lazily registered specializations.
+  spec_range loaded_specializations() const {
+    return spec_range(loaded_spec_begin(), loaded_spec_end());
+  }
+
+  spec_iterator loaded_spec_begin() const {
+    return makeSpecIterator(getCommonPtr()->Specializations, false);
+  }
+
+  spec_iterator loaded_spec_end() const {
+    return makeSpecIterator(getCommonPtr()->Specializations, true);
+  }
+
   /// Retrieve the "injected" template arguments that correspond to the
   /// template parameters of this function template.
   ///
@@ -2448,6 +2462,20 @@ public:
     return makeSpecIterator(getSpecializations(), true);
   }
 
+  /// All specializations that that have already been loaded, ie avoiding
+  /// deserialization of lazily registered specializations.
+  spec_range loaded_specializations() const {
+    return spec_range(loaded_spec_begin(), loaded_spec_end());
+  }
+
+  spec_iterator loaded_spec_begin() const {
+    return makeSpecIterator(getCommonPtr()->Specializations, false);
+  }
+
+  spec_iterator loaded_spec_end() const {
+    return makeSpecIterator(getCommonPtr()->Specializations, true);
+  }
+
   // Implement isa/cast/dyncast support
   static bool classof(const Decl *D) { return classofKind(D->getKind()); }
   static bool classofKind(Kind K) { return K == ClassTemplate; }
@@ -3251,6 +3279,20 @@ public:
     return makeSpecIterator(getSpecializations(), true);
   }
 
+  /// All specializations that that have already been loaded, ie avoiding
+  /// deserialization of lazily registered specializations.
+  spec_range loaded_specializations() const {
+    return spec_range(loaded_spec_begin(), loaded_spec_end());
+  }
+
+  spec_iterator loaded_spec_begin() const {
+    return makeSpecIterator(getCommonPtr()->Specializations, false);
+  }
+
+  spec_iterator loaded_spec_end() const {
+    return makeSpecIterator(getCommonPtr()->Specializations, true);
+  }
+
   // Implement isa/cast/dyncast support
   static bool classof(const Decl *D) { return classofKind(D->getKind()); }
   static bool classofKind(Kind K) { return K == VarTemplate; }
-- 
2.42.0

