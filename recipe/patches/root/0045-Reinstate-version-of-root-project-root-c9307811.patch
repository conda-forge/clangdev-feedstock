From f839d2d40b77d7565269bacf3e57ef8567edddd4 Mon Sep 17 00:00:00 2001
From: Vassil Vassilev <v.g.vassilev@gmail.com>
Date: Mon, 14 Dec 2020 10:56:27 +0000
Subject: [PATCH 45/83] Reinstate version of root-project/root@c9307811

Original message:
"
[cxxmodules] Do not cache the file lookup failure.

In cases where we have the module cache path and prebuilt module path pointing
to the same location, the FileManager should not cache the module file lookup
failure because it may currently be building the module.

This patch is necessary because the global module index is built from the
module cache path and it is loaded from the prebuilt module path.

In a full explicit or implicit module build infrastructure this is not a problem.
However, in a mixed scenario (where modules for third-party dependencies are
built implicitly) such as ours this is problematic. One of the reasons is that
we cannot configure the prebuilt modules paths or module cache paths externally.
This is because the interpreter (at construction time) #includes RuntimeUniverse
which may trigger module build.

This patch allows us to refactor some of the code working around this issue.
---
 lib/Lex/HeaderSearch.cpp | 13 ++++++++++++-
 1 file changed, 12 insertions(+), 1 deletion(-)

diff --git a/lib/Lex/HeaderSearch.cpp b/lib/Lex/HeaderSearch.cpp
index de1b1a03ad..3fb5c61d33 100644
--- a/lib/Lex/HeaderSearch.cpp
+++ b/lib/Lex/HeaderSearch.cpp
@@ -152,13 +152,23 @@ std::string HeaderSearch::getPrebuiltModuleFileName(StringRef ModuleName,
   if (FileMapOnly || HSOpts->PrebuiltModulePaths.empty())
     return {};
 
+
+  llvm::StringRef ModuleCachePath = getModuleCachePath();
+  bool CacheFailure = true;
+
   // Then go through each prebuilt module directory and try to find the pcm
   // file.
   for (const std::string &Dir : HSOpts->PrebuiltModulePaths) {
     SmallString<256> Result(Dir);
     llvm::sys::fs::make_absolute(Result);
     llvm::sys::path::append(Result, ModuleName + ".pcm");
-    if (getFileMgr().getFile(Result.str()))
+    // If we have the same ModuleCachePath and PrebuiltModulePath pointing
+    // to the same folder we should not cache the file lookup failure as it
+    // may be currently building an implicit module.
+    if (!ModuleCachePath.empty() && ModuleCachePath == Dir)
+      CacheFailure = false;
+
+    if (getFileMgr().getFile(Result.str(), /*Open=*/false, CacheFailure))
       return std::string(Result);
   }
   return {};
@@ -182,6 +192,7 @@ std::string HeaderSearch::getPrebuiltImplicitModuleFileName(Module *Module) {
   return {};
 }
 
+
 std::string HeaderSearch::getCachedModuleFileName(StringRef ModuleName,
                                                   StringRef ModuleMapPath) {
   return getCachedModuleFileNameImpl(ModuleName, ModuleMapPath,
-- 
2.34.1

