From 977fde2e06dde9befa504a404d16895e3cc6d364 Mon Sep 17 00:00:00 2001
From: Philippe Canal <pcanal@fnal.gov>
Date: Tue, 28 Jan 2020 15:49:01 -0600
Subject: [PATCH 098/107] Add support for DiagnosticEngine state change within
 recursive parsing.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This fixes ROOT-10504.

the script:
```

namespace boost { namespace mpl {

// Commenting the next line make the assert failure go away
struct TTUBE {};

}}

```
reproduce the problem with 'just' ROOT.  The trigger is the auto-loading of a library that has a dictionary with has forward decl string .. which all starts with:
```
    static const char* fwdDeclCode = R"DICTFWDDCLS(
extern int __Cling_Autoloading_Map;
....
```

The order of parsing is (with many ellipsis):
```
"<<< cling interactive line includer >>>" : line 9  : #include “standalone.C”
standalone.C : line 1 : #pragma GCC diagnostic push
standalone.C : line 2 : #pragma GCC diagnostic ignored "-Wuninitialized"    // Inserted in Diag map
standalone.C : line 3 : #pragma GCC diagnostic ignored "-Wsign-conversion"  // Inserted in Diag map
standalone.C : line 8 : struct TTUBE {} ; // triggers auto-loading and thus recursive parsing.

"<<< cling interactive line includer >>>" : line 10  : parse dict fwd declare string
input_line_9 : line 2 : #pragma clang diagnostic ignored "-Wkeyword-compat"        // Inserted in Diag map
input_line_9 : line 3 : #pragma clang diagnostic ignored "-Wignored-attributes"    // Inserted in Diag map
input_line_9 : line 4 : #pragma clang diagnostic ignored "-Wreturn-type-c-linkage" // Inserted in Diag map

end of file

standalone.C : line 12 : #pragma GCC diagnostic pop // Inserted in Diag map
```
The last line triggers the assert because when recording the state change, it records it as being from
```
   standalone.C : line 12
   "<<< cling interactive line includer >>>" : line 9
```
but when recording the last one, it notices that the last state change that happened, indirectly, for the file '<<< cling interactive line includer >>>' happened at line 10 (because of the pragma in input_line_9 which is 'recorded' as being included by line 10),
which makes that the state change for ```standalone.C:12``` happens 'ealier' than the last state change as far as the pseudo-file "<<< cling interactive line includer >>>" is concerned.  For that pseudo-file, the last state change happened line 10 but the state change bbeing processed happens line 9 (where Standalone.C is being included).
---
 lib/Basic/Diagnostic.cpp | 24 +++++++++++++++++++++++-
 1 file changed, 23 insertions(+), 1 deletion(-)

diff --git a/lib/Basic/Diagnostic.cpp b/lib/Basic/Diagnostic.cpp
index c63b029077..e9da7aa336 100644
--- a/lib/Basic/Diagnostic.cpp
+++ b/lib/Basic/Diagnostic.cpp
@@ -180,7 +180,29 @@ void DiagnosticsEngine::DiagStateMap::append(SourceManager &SrcMgr,
        Offset = F->ParentOffset, F = F->Parent) {
     F->HasLocalTransitions = true;
     auto &Last = F->StateTransitions.back();
-    assert(Last.Offset <= Offset && "state transitions added out of order");
+    if (Last.Offset > Offset) {
+      // Deal with a state change induce by recursive parsing.  The first parsing is
+      // suspended and a (recursive) parsing is started between associated (in the upper/outer
+      // file) with a newer line (hence greater offset).  After the end of the recursive
+      // parsing, we go back to the first parsing and any state change will done 'earlier'
+      // and trigger:
+      //   assert(Last.Offset <= Offset && "state transitions added out of order");
+      auto OnePastIt = std::upper_bound(
+        F->StateTransitions.begin(), F->StateTransitions.end(), Offset,
+        [](unsigned Offset, const DiagStatePoint &P) {
+          return Offset < P.Offset;
+        });
+      if (OnePastIt == F->StateTransitions.begin() || (OnePastIt[-1].Offset != Offset)) {
+        F->StateTransitions.insert( OnePastIt, {State, Offset});
+      } else {
+        auto &Prev = OnePastIt[-1];
+        if (Prev.State == State)
+          break;
+        Prev.State = State;
+        continue;
+      }
+      continue;
+    }
 
     if (Last.Offset == Offset) {
       if (Last.State == State)
-- 
2.35.1

