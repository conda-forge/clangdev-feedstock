From d37cfc2d72da0b49c7dfde58c8fc78e7fd610346 Mon Sep 17 00:00:00 2001
From: Jonas Hahnfeld <jonas.hahnfeld@cern.ch>
Date: Thu, 11 May 2023 18:33:20 +0200
Subject: [PATCH 42/74] Partial backport of D144626 to fix Decl merging with
 constraints

This is a partial backport of the changes to isSameEntity from commit
https://github.com/llvm/llvm-project/commit/2408f97652caadf733a879e1d7d9c0702a80d609
(which lives in a different file in LLVM 13 and was moved to ASTContext
at a later point). The gist of the change is that during template
instantiation, the constraint / requires clause also gets instantiated
and potentially changed. This means that if a function with constraints
is used in one module, but included as-is in another, the two of them
could not be merged.

This change fixes the following error seen on macOS 13 with C++20:
```
/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/reverse_iterator.h:141:23: error: 'std::reverse_iterator<std::string *>::operator->' from module 'std.iterator.__iterator.reverse_iterator' is not present in definition of 'std::reverse_iterator<std::string *>' in module 'std.iterator.__iterator.reverse_iterator'
    constexpr pointer operator->() const
                      ^
/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/reverse_iterator.h:141:23: note: declaration of 'operator->' does not match
```

Note that this particular code was recently reverted in commit
https://github.com/llvm/llvm-project/commit/aeee4ebd689171c963aa5d973e14cb6e731eb147
However, as far as I can tell, this relies on the implementation of
deferred concept instantiation which solves the problem from a different
angle, but cannot be easily backported to our copy of LLVM:
https://github.com/llvm/llvm-project/commit/babdef27c503c0bbbcc017e9f88affddda90ea4e
---
 clang/lib/Serialization/ASTReaderDecl.cpp | 23 +++++++++++++++++++++--
 1 file changed, 21 insertions(+), 2 deletions(-)

diff --git a/clang/lib/Serialization/ASTReaderDecl.cpp b/clang/lib/Serialization/ASTReaderDecl.cpp
index ff79f91e5db1..9b2220d7c74d 100644
--- a/clang/lib/Serialization/ASTReaderDecl.cpp
+++ b/clang/lib/Serialization/ASTReaderDecl.cpp
@@ -3143,8 +3143,27 @@ static bool isSameEntity(NamedDecl *X, NamedDecl *Y) {
 
     ASTContext &C = FuncX->getASTContext();
 
-    const Expr *XRC = FuncX->getTrailingRequiresClause();
-    const Expr *YRC = FuncY->getTrailingRequiresClause();
+    // The trailing require clause of instantiated function may change during
+    // the semantic analysis. Trying to get the primary template function (if
+    // exists) to compare the primary trailing require clause.
+    auto TryToGetPrimaryTemplatedFunction =
+        [](const FunctionDecl *FD) -> const FunctionDecl * {
+      switch (FD->getTemplatedKind()) {
+      case FunctionDecl::TK_FunctionTemplate:
+        return FD->getDescribedFunctionTemplate()->getTemplatedDecl();
+      case FunctionDecl::TK_MemberSpecialization:
+        return FD->getInstantiatedFromMemberFunction();
+      case FunctionDecl::TK_FunctionTemplateSpecialization:
+        return FD->getPrimaryTemplate()->getTemplatedDecl();
+      default:
+        return FD;
+      }
+    };
+    const FunctionDecl *PrimaryX = TryToGetPrimaryTemplatedFunction(FuncX);
+    const FunctionDecl *PrimaryY = TryToGetPrimaryTemplatedFunction(FuncY);
+
+    const Expr *XRC = PrimaryX->getTrailingRequiresClause();
+    const Expr *YRC = PrimaryY->getTrailingRequiresClause();
     if (!XRC != !YRC)
       return false;
     if (XRC) {
-- 
2.42.0

