From 44c8115f01a3ad95414edb24106906243d9f4688 Mon Sep 17 00:00:00 2001
From: Utkarsh Saxena <usx@google.com>
Date: Wed, 17 Aug 2022 16:44:41 +0200
Subject: [PATCH 57/89] Do not evaluate dependent immediate invocations

We deferred the evaluation of dependent immediate invocations in https://reviews.llvm.org/D119375 until instantiation.
We should also not consider them referenced from a non-consteval context.

Fixes: https://github.com/llvm/llvm-project/issues/55601

```
template<typename T>
class Bar {
  consteval static T x() { return 5; }
 public:
  Bar() : a(x()) {}

 private:
  int a;
};

Bar<int> g();
```
Is now accepted by clang. Previously it errored with: `cannot take address of consteval function 'x' outside of an immediate invocation  Bar() : a(x()) {}`

Differential Revision: https://reviews.llvm.org/D132031

(cherry picked from commit 0e0e8b65765e32776a5188e96d1672baeb11b16c)
---
 clang/lib/Sema/SemaExpr.cpp            |  2 +-
 clang/test/SemaCXX/cxx2a-consteval.cpp | 32 ++++++++++++++++++++++++++
 2 files changed, 33 insertions(+), 1 deletion(-)

diff --git a/clang/lib/Sema/SemaExpr.cpp b/clang/lib/Sema/SemaExpr.cpp
index 035381b4c63f..de19ce4e0cce 100644
--- a/clang/lib/Sema/SemaExpr.cpp
+++ b/clang/lib/Sema/SemaExpr.cpp
@@ -18730,7 +18730,7 @@ void Sema::MarkDeclRefReferenced(DeclRefExpr *E, const Expr *Base) {
 
   if (auto *FD = dyn_cast<FunctionDecl>(E->getDecl()))
     if (!isConstantEvaluated() && FD->isConsteval() &&
-        !RebuildingImmediateInvocation)
+        !RebuildingImmediateInvocation && !FD->isDependentContext())
       ExprEvalContexts.back().ReferenceToConsteval.insert(E);
   MarkExprReferenced(*this, E->getLocation(), E->getDecl(), E, OdrUse,
                      RefsMinusAssignments);
diff --git a/clang/test/SemaCXX/cxx2a-consteval.cpp b/clang/test/SemaCXX/cxx2a-consteval.cpp
index ecf8c1e0f5bd..195362ccb376 100644
--- a/clang/test/SemaCXX/cxx2a-consteval.cpp
+++ b/clang/test/SemaCXX/cxx2a-consteval.cpp
@@ -594,3 +594,35 @@ void test() {
 }
 
 } // namespace special_ctor
+
+// https://github.com/llvm/llvm-project/issues/55601
+namespace issue_55601 {
+template<typename T>
+class Bar {
+  consteval static T x() { return 5; }  // expected-note {{non-constexpr constructor 'derp' cannot be used in a constant expression}}
+ public:
+  Bar() : a(x()) {} // expected-error {{call to consteval function 'issue_55601::Bar<issue_55601::derp>::x' is not a constant expression}}
+                    // expected-error@-1 {{call to consteval function 'issue_55601::derp::operator int' is not a constant expression}}
+                    // expected-note@-2 {{in call to 'x()'}}
+                    // expected-note@-3 {{non-literal type 'issue_55601::derp' cannot be used in a constant expression}}
+ private:
+  int a;
+};
+Bar<int> f;
+Bar<float> g;
+
+struct derp {
+  // Can't be used in a constant expression
+  derp(int); // expected-note {{declared here}}
+  consteval operator int() const { return 5; }
+};
+Bar<derp> a; // expected-note {{in instantiation of member function 'issue_55601::Bar<issue_55601::derp>::Bar' requested here}}
+
+struct constantDerp {
+  // Can be used in a constant expression.
+  consteval constantDerp(int) {} 
+  consteval operator int() const { return 5; }
+};
+Bar<constantDerp> b;
+
+} // namespace issue_55601
