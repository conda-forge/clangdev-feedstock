From d0fbce47c6310aaea528ec27a4cf2dbae5bc12c4 Mon Sep 17 00:00:00 2001
From: Axel Naumann <Axel.Naumann@cern.ch>
Date: Wed, 16 Jul 2014 11:28:29 +0200
Subject: [PATCH 36/50] Update the DeclContext used for lookup to point to the
 definition.

While the ASTReader fills the existing Decl, we create a new redecl.
This patch can be removed once we use real PCMs.

Co-authored-by: Philippe Canal <pcanal@fnal.gov>
---
 clang/include/clang/Sema/Sema.h     |  2 +-
 clang/lib/Sema/SemaCXXScopeSpec.cpp | 20 ++++++++++++++++----
 clang/lib/Sema/SemaDecl.cpp         | 11 ++++++++---
 clang/lib/Sema/SemaDeclCXX.cpp      |  2 +-
 clang/lib/Sema/SemaExprCXX.cpp      |  3 ++-
 clang/lib/Sema/SemaTemplate.cpp     |  5 +++++
 6 files changed, 33 insertions(+), 10 deletions(-)

diff --git a/clang/include/clang/Sema/Sema.h b/clang/include/clang/Sema/Sema.h
index 3f0f77f21..bbfb71cd5 100644
--- a/clang/include/clang/Sema/Sema.h
+++ b/clang/include/clang/Sema/Sema.h
@@ -2732,7 +2732,7 @@ public:
 
 public:
   // Marks SS invalid if it represents an incomplete type.
-  bool RequireCompleteDeclContext(CXXScopeSpec &SS, DeclContext *DC);
+  bool RequireCompleteDeclContext(CXXScopeSpec &SS, DeclContext *&DC);
   // Complete an enum decl, maybe without a scope spec.
   bool RequireCompleteEnumDecl(EnumDecl *D, SourceLocation L,
                                CXXScopeSpec *SS = nullptr);
diff --git a/clang/lib/Sema/SemaCXXScopeSpec.cpp b/clang/lib/Sema/SemaCXXScopeSpec.cpp
index f04f7f992..f72516003 100644
--- a/clang/lib/Sema/SemaCXXScopeSpec.cpp
+++ b/clang/lib/Sema/SemaCXXScopeSpec.cpp
@@ -190,7 +190,7 @@ CXXRecordDecl *Sema::getCurrentInstantiationOf(NestedNameSpecifier *NNS) {
 /// a class template specialization that is not a complete type, we
 /// will attempt to instantiate that class template.
 bool Sema::RequireCompleteDeclContext(CXXScopeSpec &SS,
-                                      DeclContext *DC) {
+                                      DeclContext *&DC) {
   assert(DC && "given null context");
 
   TagDecl *tag = dyn_cast<TagDecl>(DC);
@@ -216,6 +216,12 @@ bool Sema::RequireCompleteDeclContext(CXXScopeSpec &SS,
   // The type must be complete.
   if (RequireCompleteType(loc, type, diag::err_incomplete_nested_name_spec,
                           SS.getRange())) {
+    // The actual information about the decl may have been loaded via an
+    // external source that created a new AST node/decl for the definition
+    // rather than reusing the one we had (DC) like the ASTReader does.
+    // To avoid the caller to continue using the still incomplete decl, let's
+    // set it to the definition.
+    DC = tag->getDefinition();
     SS.SetInvalid(SS.getRange());
     return true;
   }
@@ -444,9 +450,15 @@ bool Sema::BuildCXXNestedNameSpecifier(Scope *S, NestedNameSpecInfo &IdInfo,
     // nested-name-specifier.
 
     // The declaration context must be complete.
-    if (!LookupCtx->isDependentContext() &&
-        RequireCompleteDeclContext(SS, LookupCtx))
-      return true;
+    if (!LookupCtx->isDependentContext()) {
+      if (RequireCompleteDeclContext(SS, LookupCtx)) {
+        return true;
+      } else if (TagDecl* TD = dyn_cast<TagDecl>(LookupCtx)) {
+        // Update the DeclContext to point to the Tag definition.
+        LookupCtx = TD->getDefinition();
+      }
+    }
+
 
     LookupQualifiedName(Found, LookupCtx);
 
diff --git a/clang/lib/Sema/SemaDecl.cpp b/clang/lib/Sema/SemaDecl.cpp
index 320ffba55..eab6f5425 100644
--- a/clang/lib/Sema/SemaDecl.cpp
+++ b/clang/lib/Sema/SemaDecl.cpp
@@ -352,9 +352,14 @@ ParsedType Sema::getTypeName(const IdentifierInfo &II, SourceLocation NameLoc,
       return nullptr;
     }
 
-    if (!LookupCtx->isDependentContext() &&
-        RequireCompleteDeclContext(*SS, LookupCtx))
-      return nullptr;
+    if (!LookupCtx->isDependentContext()) {
+      if (RequireCompleteDeclContext(*SS, LookupCtx)) {
+        return nullptr;
+      } else if (TagDecl* TD = dyn_cast<TagDecl>(LookupCtx)) {
+        // Update the DeclContext to point to the Tag definition.
+        LookupCtx = TD->getDefinition();
+      }
+    }
   }
 
   // In the case where we know that the identifier is a class name, we know that
diff --git a/clang/lib/Sema/SemaDeclCXX.cpp b/clang/lib/Sema/SemaDeclCXX.cpp
index 85de46c9a..99ae255c8 100644
--- a/clang/lib/Sema/SemaDeclCXX.cpp
+++ b/clang/lib/Sema/SemaDeclCXX.cpp
@@ -13240,7 +13240,7 @@ bool Sema::CheckUsingDeclQualifier(SourceLocation UsingLoc, bool HasTypename,
     if (Cxx20Enumerator)
       return false; // OK
 
-    auto *RD = NamedContext
+    DeclContext *RD = NamedContext
                    ? cast<CXXRecordDecl>(NamedContext->getRedeclContext())
                    : nullptr;
     if (RD && !RequireCompleteDeclContext(const_cast<CXXScopeSpec &>(SS), RD)) {
diff --git a/clang/lib/Sema/SemaExprCXX.cpp b/clang/lib/Sema/SemaExprCXX.cpp
index c6621402a..47c9fd3f6 100644
--- a/clang/lib/Sema/SemaExprCXX.cpp
+++ b/clang/lib/Sema/SemaExprCXX.cpp
@@ -106,7 +106,8 @@ ParsedType Sema::getConstructorName(const IdentifierInfo &II,
     return ParsedType::make(T);
   }
 
-  if (SS.isNotEmpty() && RequireCompleteDeclContext(SS, CurClass))
+  DeclContext *DC = CurClass;
+  if (SS.isNotEmpty() && RequireCompleteDeclContext(SS, DC))
     return ParsedType();
 
   // Find the injected-class-name declaration. Note that we make no attempt to
diff --git a/clang/lib/Sema/SemaTemplate.cpp b/clang/lib/Sema/SemaTemplate.cpp
index 2c59bbb7f..35828f39b 100644
--- a/clang/lib/Sema/SemaTemplate.cpp
+++ b/clang/lib/Sema/SemaTemplate.cpp
@@ -428,6 +428,11 @@ bool Sema::LookupTemplateName(LookupResult &Found, Scope *S, CXXScopeSpec &SS,
     // The declaration context must be complete.
     if (LookupCtx && RequireCompleteDeclContext(SS, LookupCtx))
       return true;
+
+    if (TagDecl* TD = dyn_cast_or_null<TagDecl>(LookupCtx)) {
+      // Update the DeclContext to point to the Tag definition.
+      LookupCtx = TD->getDefinition();
+    }
   }
 
   bool ObjectTypeSearchedInScope = false;
