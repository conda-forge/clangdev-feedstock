From 81dfa405c5ea15deae501f6182732f2ac5582919 Mon Sep 17 00:00:00 2001
From: Vassil Vassilev <vvasilev@cern.ch>
Date: Tue, 1 Oct 2013 12:33:16 +0200
Subject: [PATCH 56/73] Implement implicit auto keyword injection in clang
 itself.

Co-authored-by: Axel Naumann <Axel.Naumann@cern.ch>
Co-authored-by: Javier Lopez-Gomez <javier.lopez.gomez@cern.ch>
---
 clang/lib/Sema/SemaExpr.cpp | 33 +++++++++++++++++++++++++++++++++
 1 file changed, 33 insertions(+)

diff --git a/clang/lib/Sema/SemaExpr.cpp b/clang/lib/Sema/SemaExpr.cpp
index de19ce4e0cce..f8bf12d39b14 100644
--- a/clang/lib/Sema/SemaExpr.cpp
+++ b/clang/lib/Sema/SemaExpr.cpp
@@ -14134,6 +14134,39 @@ ExprResult Sema::CreateBuiltinBinOp(SourceLocation OpLoc,
 
   switch (Opc) {
   case BO_Assign:
+    // ROOT hack: we want to support constructs like n = new TNamed() and if n
+    // wasn't declared we should declare it.
+    if (DeclRefExpr* DRE = dyn_cast<DeclRefExpr>(LHSExpr)) {
+      if (VarDecl* VD = dyn_cast<VarDecl>(DRE->getDecl()))
+        if (const AutoType* aTy = dyn_cast<AutoType>(VD->getType().getTypePtr()))
+          if (const AnnotateAttr* A = VD->getAttr<AnnotateAttr>())
+            // If the deduction didn't take place and it is our special 
+            // annotation
+            if (!aTy->isDeduced() && A->getAnnotation().equals("__Auto")) {
+            QualType ResTy;
+            ASTContext& C = getASTContext();
+            TypeSourceInfo* TrivialTSI
+              = C.getTrivialTypeSourceInfo(VD->getType());
+            if (DeduceAutoType(TrivialTSI, RHSExpr, ResTy) != DAR_Succeeded) {
+               Diag(VD->getLocation(), diag::err_auto_var_requires_init)
+                  << VD->getDeclName() << VD->getType();
+               VD->setInvalidDecl();
+
+               return ExprError();
+            }
+            VD->setTypeSourceInfo(C.getTrivialTypeSourceInfo(ResTy));
+            VD->setType(ResTy);
+            VD->setInit(DefaultLvalueConversion(RHSExpr).get());
+            PushOnScopeChains(VD, getCurScope(), /*Add to ctx*/true);
+
+
+            // Here we need to return 'something' to make the parser happy. 
+            // A reference to the decl is semantically closest to what we want.
+            return BuildDeclRefExpr(VD, VD->getType(), VK_LValue, 
+                                    SourceLocation());
+          }
+    }
+
     ResultTy = CheckAssignmentOperands(LHS.get(), RHS, OpLoc, QualType());
     if (getLangOpts().CPlusPlus &&
         LHS.get()->getObjectKind() != OK_ObjCProperty) {
-- 
2.42.0

