From 29512ce245a211df2a39f4e1e63d7bf4cc012e37 Mon Sep 17 00:00:00 2001
From: Axel Naumann <Axel.Naumann@cern.ch>
Date: Mon, 26 Aug 2013 15:08:12 +0200
Subject: [PATCH 13/50] More RAIIs for autoloading.

Co-authored-by: Jonas Hahnfeld <jonas.hahnfeld@cern.ch>
---
 clang/include/clang/Lex/Preprocessor.h | 71 ++++++++++++++++++++++++++
 clang/include/clang/Sema/Sema.h        | 33 ++++++++++++
 2 files changed, 104 insertions(+)

diff --git a/clang/include/clang/Lex/Preprocessor.h b/clang/include/clang/Lex/Preprocessor.h
index 26303d9e0..e0e6010e7 100644
--- a/clang/include/clang/Lex/Preprocessor.h
+++ b/clang/include/clang/Lex/Preprocessor.h
@@ -1698,6 +1698,77 @@ public:
                      IsReinject);
   }
 
+  /// A RAII object to temporarily reset PP's state and restore it.
+  class CleanupAndRestoreCacheRAII {
+  private:
+    Preprocessor &PP;
+    CachedTokensTy SavedCachedTokens;
+    CachedTokensTy::size_type SavedCachedLexPos;
+    std::vector<CachedTokensTy::size_type> SavedBacktrackPositions;
+    std::vector<IncludeStackInfo> SavedStack;
+    Lexer *SavedCurLexer;
+    PreprocessorLexer *SavedCurPPLexer;
+    TokenLexer* SavedCurTokenLexer;
+    ConstSearchDirIterator SavedCurDirLookup;
+    LexerCallback SavedCurLexerCallback;
+    unsigned SavedLexLevel;
+
+  public:
+    CleanupAndRestoreCacheRAII(Preprocessor &PP)
+        : PP(PP), SavedCachedTokens(std::move(PP.CachedTokens)),
+          SavedCachedLexPos(PP.CachedLexPos),
+          SavedBacktrackPositions(std::move(PP.BacktrackPositions)),
+          SavedStack(std::move(PP.IncludeMacroStack)),
+          SavedCurLexer(PP.CurLexer.release()), SavedCurPPLexer(PP.CurPPLexer),
+          SavedCurTokenLexer(PP.CurTokenLexer.release()),
+          SavedCurDirLookup(PP.CurDirLookup),
+          SavedCurLexerCallback(PP.CurLexerCallback),
+          SavedLexLevel(PP.LexLevel) {
+      PP.CachedTokens.clear();
+      PP.CachedLexPos = 0;
+      PP.BacktrackPositions.clear();
+      PP.IncludeMacroStack.clear();
+      PP.CurLexer.reset(0);
+      PP.CurPPLexer = 0;
+      PP.CurTokenLexer.reset(0);
+      PP.CurDirLookup = 0;
+      PP.CurLexerCallback = CLK_CachingLexer;
+      PP.LexLevel = 0;
+    }
+
+    void pop() {
+      if (SavedCurLexerCallback == nullptr)
+        return;
+
+      // ExitCachingLexMode();
+      PP.CachedTokens = std::move(SavedCachedTokens);
+      PP.CachedLexPos = SavedCachedLexPos;
+      PP.BacktrackPositions = std::move(SavedBacktrackPositions);
+      PP.IncludeMacroStack = std::move(SavedStack);
+      PP.CurLexer.reset(SavedCurLexer);
+      PP.CurPPLexer = SavedCurPPLexer;
+      PP.CurTokenLexer.reset(SavedCurTokenLexer);
+      PP.CurDirLookup = SavedCurDirLookup;
+      PP.CurLexerCallback = SavedCurLexerCallback;
+      PP.LexLevel = SavedLexLevel;
+
+      SavedCachedTokens.clear();
+      SavedCachedLexPos = 0;
+      SavedBacktrackPositions.clear();
+      SavedStack.clear();
+      SavedCurLexer = 0;
+      SavedCurPPLexer = 0;
+      SavedCurTokenLexer = 0;
+      SavedCurDirLookup = 0;
+      SavedCurLexerCallback = nullptr;
+      SavedLexLevel = ~0U;
+    }
+
+    ~CleanupAndRestoreCacheRAII() {
+      pop();
+    }
+  };
+
   /// Pop the current lexer/macro exp off the top of the lexer stack.
   ///
   /// This should only be used in situations where the current state of the
diff --git a/clang/include/clang/Sema/Sema.h b/clang/include/clang/Sema/Sema.h
index 57f1e5674..6a0723fa4 100644
--- a/clang/include/clang/Sema/Sema.h
+++ b/clang/include/clang/Sema/Sema.h
@@ -13114,6 +13114,39 @@ public:
       bool SkipForSpecialization = false,
       bool ForDefaultArgumentSubstitution = false);
 
+  /// A RAII object to temporarily push a decl context and scope.
+  class ContextAndScopeRAII {
+  private:
+    Sema &S;
+    DeclContext *SavedContext;
+    Scope *SavedScope;
+    ProcessingContextState SavedContextState;
+    QualType SavedCXXThisTypeOverride;
+
+  public:
+    ContextAndScopeRAII(Sema &S, DeclContext *ContextToPush, Scope *ScopeToPush)
+        : S(S), SavedContext(S.CurContext), SavedScope(S.CurScope),
+          SavedContextState(S.DelayedDiagnostics.pushUndelayed()),
+          SavedCXXThisTypeOverride(S.CXXThisTypeOverride) {
+      assert(ContextToPush && "pushing null context");
+      S.CurContext = ContextToPush;
+      S.CurScope = ScopeToPush;
+    }
+
+    void pop() {
+      if (!SavedContext)
+        return;
+      S.CurContext = SavedContext;
+      S.CurScope = SavedScope;
+      S.DelayedDiagnostics.popUndelayed(SavedContextState);
+      S.CXXThisTypeOverride = SavedCXXThisTypeOverride;
+      SavedContext = 0;
+      SavedScope = 0;
+    }
+
+    ~ContextAndScopeRAII() { pop(); }
+  };
+
   /// RAII object to handle the state changes required to synthesize
   /// a function body.
   class SynthesizedFunctionScope {
